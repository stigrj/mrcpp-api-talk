name: inverse
layout: true
class: center, middle, inverse

---

#MRCPP
##Application Program Interface

.author[Stig Rune Jensen]

.date[3 August 2016, Stony Brook, NY]

.footnote[Slides available on [GitHub](https://github.com/stigrj/mrcpp-api-talk)]

---

layout: false
.left-column[
## Introduction
]
.right-column[
### Some intro
]

---

layout: false
.left-column[
## Analytic functions
### - Explicitly implemented
]
.right-column[
Some important analytic functions are implemented

- Polynomials
- Gaussians
- Slater functions
- Hydrogen solutions

]

---

.left-column[
## Analytic functions
### - Explicitly implemented
### - Lambdas
]
.right-column[
Some important analytic functions are implemented

- Polynomials
- Gaussians
- Slater functions
- Hydrogen solutions



General analytic function through lambda functions

```cpp
auto f = [] (const double *r) -> double;
```

]

---

.left-column[
## Analytic functions
### - Explicitly implemented
### - Lambdas
### - Example
]
.right-column[
Some important analytic functions are implemented

- Polynomials
- Gaussians
- Slater functions
- Hydrogen solutions



General analytic function through lambda functions

```cpp
auto f = [] (const double *r) -> double;
```



Hydrogen nuclear potential

```cpp
double Z = 1.0;             // Hydrogen nuclear charge
auto f = [Z] (const double *r) -> double {
    double R = sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
    return Z/R;
}
```

]

---

layout: false
.left-column[
## Multi Resolution Analysis
### -Computational domain
]
.right-column[
Define a computational domain
```cpp
int n;                          // Box size 2^{-n}
int corner[D];                  // Translation of first box
int boxes[D];                   // Number of boxes
NodeIndex<D> idx(n, corner);
BoundingBox<D> world(idx, boxes);
```

---

layout: false
.left-column[
## Multi Resolution Analysis
### -Computational domain
### -Scaling basis
]
.right-column[
Define a computational domain
```cpp
int n;                          // Box size 2^{-n}
int corner[D];                  // Translation of first box
int boxes[D];                   // Number of boxes
NodeIndex<D> idx(n, corner);
BoundingBox<D> world(idx, boxes);
```

- Two types of scaling basis
  * Legendre polynomials
  * Interpolating polynomials
- Available orders.red[<sup>*</sup>]: `\(1 \leq k \leq 40\)`

]

.footnote[.red[*] Some operators require `\(2k\)` intermediates]

---

layout: false
.left-column[
## Multi Resolution Analysis
### -Computational domain
### -Scaling basis
### -MRA
]
.right-column[
- Define a computational domain
```cpp
int n;                          // Box size 2^{-n}
int corner[D];                  // Translation of first box
int boxes[D];                   // Number of boxes
NodeIndex<D> idx(n, corner);
BoundingBox<D> world(idx, boxes);
```

- Two types of scaling basis
  * Legendre polynomials
  * Interpolating polynomials
- Available orders<sup>.red[*]</sup>: `\(1 \leq k \leq 40\)`

Combine world and basis to get MRA
```cpp
int k;                          // Polynomial order
InterpolatingBasis basis(k);
MultiResolutionAnalysis<D> MRA(world, basis);
```

]

.footnote[.red[*] Some operators require `\(2k\)` intermediates]

---

layout: false
.left-column[
## Function representations
]
.right-column[
Ways of constructing MW representations
- Projection of analytic function
- Arithmetic operations
- Application of MW operator
]

---

## Acknowldegements

- Luca Frediani

- Tor Fl√•

- Radovan Bast

- Jonas Juselius

---

name: last-page
template: inverse

## Thanks for your attention!

Slideshow created using [remark] and served using [cicero]

[remark]: https://github.com/gnab/remark
[cicero]: https://github.com/bast/cicero
